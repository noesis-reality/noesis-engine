// automatically generated by the FlatBuffers compiler, do not modify

package noesis.protocol

import com.google.flatbuffers.kotlin.*
import kotlin.jvm.JvmInline
@Suppress("unused")
class ReasoningStream : Table() {

    fun init(i: Int, buffer: ReadWriteBuffer) : ReasoningStream = reset(i, buffer)

    val id : String? get() = lookupField(4, null ) { string(it + bufferPos) }
    fun idAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 4, 1)

    val sequenceId : UInt get() = lookupField(6, 0u ) { bb.getUInt(it + bufferPos) }

    val reasoningStep : noesis.protocol.ReasoningStep? get() = reasoningStep(noesis.protocol.ReasoningStep())
    fun reasoningStep(obj: noesis.protocol.ReasoningStep) : noesis.protocol.ReasoningStep? = lookupField(8, null ) { obj.init(indirect(it + bufferPos), bb) }

    fun contextTokens(j: Int) : UInt = lookupField(10, 0u ) { bb.getUInt(vector(it) + j * 4) }
    val contextTokensLength : Int get() = lookupField(10, 0 ) { vectorLength(it) }
    fun contextTokensAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 10, 4)

    val contextSummary : String? get() = lookupField(12, null ) { string(it + bufferPos) }
    fun contextSummaryAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 12, 1)

    val isFinal : Boolean get() = lookupField(14, false ) { 0.toByte() != bb.get(it + bufferPos) }

    companion object {
        fun validateVersion() = VERSION_2_0_8

        fun asRoot(buffer: ReadWriteBuffer) : ReasoningStream = asRoot(buffer, ReasoningStream())
        fun asRoot(buffer: ReadWriteBuffer, obj: ReasoningStream) : ReasoningStream = obj.init(buffer.getInt(buffer.limit) + buffer.limit, buffer)


        fun createReasoningStream(builder: FlatBufferBuilder, idOffset: Offset<String>, sequenceId: UInt, reasoningStepOffset: Offset<noesis.protocol.ReasoningStep>, contextTokensOffset: VectorOffset<UInt>, contextSummaryOffset: Offset<String>, isFinal: Boolean) : Offset<ReasoningStream> {
            builder.startTable(6)
            addContextSummary(builder, contextSummaryOffset)
            addContextTokens(builder, contextTokensOffset)
            addReasoningStep(builder, reasoningStepOffset)
            addSequenceId(builder, sequenceId)
            addId(builder, idOffset)
            addIsFinal(builder, isFinal)
            return endReasoningStream(builder)
        }
        fun startReasoningStream(builder: FlatBufferBuilder) = builder.startTable(6)

        fun addId(builder: FlatBufferBuilder, id: Offset<String>) = builder.add(0, id, 0)

        fun addSequenceId(builder: FlatBufferBuilder, sequenceId: UInt) = builder.add(1, sequenceId, 0u)

        fun addReasoningStep(builder: FlatBufferBuilder, reasoningStep: Offset<noesis.protocol.ReasoningStep>) = builder.add(2, reasoningStep, 0)

        fun addContextTokens(builder: FlatBufferBuilder, contextTokens: VectorOffset<UInt>) = builder.add(3, contextTokens, 0)

        fun createContextTokensVector(builder: FlatBufferBuilder, vector:UIntArray) : VectorOffset<UInt> {
            builder.startVector(4, vector.size, 4)
            for (i in vector.size - 1 downTo 0) {
                builder.add(vector[i])
            }
            return builder.endVector()
        }

        fun startContextTokensVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun addContextSummary(builder: FlatBufferBuilder, contextSummary: Offset<String>) = builder.add(4, contextSummary, 0)

        fun addIsFinal(builder: FlatBufferBuilder, isFinal: Boolean) = builder.add(5, isFinal, false)

        fun endReasoningStream(builder: FlatBufferBuilder) : Offset<ReasoningStream> {
            val o: Offset<ReasoningStream> = builder.endTable()
            return o
        }
    }
}

typealias ReasoningStreamOffsetArray = OffsetArray<ReasoningStream>

inline fun ReasoningStreamOffsetArray(size: Int, crossinline call: (Int) -> Offset<ReasoningStream>): ReasoningStreamOffsetArray =
    ReasoningStreamOffsetArray(IntArray(size) { call(it).value })
