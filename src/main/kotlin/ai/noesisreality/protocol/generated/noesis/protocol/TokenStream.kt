// automatically generated by the FlatBuffers compiler, do not modify

package noesis.protocol

import com.google.flatbuffers.kotlin.*
import kotlin.jvm.JvmInline
@Suppress("unused")
class TokenStream : Table() {

    fun init(i: Int, buffer: ReadWriteBuffer) : TokenStream = reset(i, buffer)

    val id : String? get() = lookupField(4, null ) { string(it + bufferPos) }
    fun idAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 4, 1)

    val sequenceId : UInt get() = lookupField(6, 0u ) { bb.getUInt(it + bufferPos) }

    fun tokens(j: Int) : UInt = lookupField(8, 0u ) { bb.getUInt(vector(it) + j * 4) }
    val tokensLength : Int get() = lookupField(8, 0 ) { vectorLength(it) }
    fun tokensAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 8, 4)

    val textDelta : String? get() = lookupField(10, null ) { string(it + bufferPos) }
    fun textDeltaAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 10, 1)

    val isFinal : Boolean get() = lookupField(12, false ) { 0.toByte() != bb.get(it + bufferPos) }

    val shouldContinue : Boolean get() = lookupField(14, true ) { 0.toByte() != bb.get(it + bufferPos) }

    val batchTimeMs : UInt get() = lookupField(16, 0u ) { bb.getUInt(it + bufferPos) }

    val cumulativeTokens : UInt get() = lookupField(18, 0u ) { bb.getUInt(it + bufferPos) }

    val instantaneousSpeed : Double get() = lookupField(20, 0.0 ) { bb.getDouble(it + bufferPos) }

    companion object {
        fun validateVersion() = VERSION_2_0_8

        fun asRoot(buffer: ReadWriteBuffer) : TokenStream = asRoot(buffer, TokenStream())
        fun asRoot(buffer: ReadWriteBuffer, obj: TokenStream) : TokenStream = obj.init(buffer.getInt(buffer.limit) + buffer.limit, buffer)


        fun createTokenStream(builder: FlatBufferBuilder, idOffset: Offset<String>, sequenceId: UInt, tokensOffset: VectorOffset<UInt>, textDeltaOffset: Offset<String>, isFinal: Boolean, shouldContinue: Boolean, batchTimeMs: UInt, cumulativeTokens: UInt, instantaneousSpeed: Double) : Offset<TokenStream> {
            builder.startTable(9)
            addInstantaneousSpeed(builder, instantaneousSpeed)
            addCumulativeTokens(builder, cumulativeTokens)
            addBatchTimeMs(builder, batchTimeMs)
            addTextDelta(builder, textDeltaOffset)
            addTokens(builder, tokensOffset)
            addSequenceId(builder, sequenceId)
            addId(builder, idOffset)
            addShouldContinue(builder, shouldContinue)
            addIsFinal(builder, isFinal)
            return endTokenStream(builder)
        }
        fun startTokenStream(builder: FlatBufferBuilder) = builder.startTable(9)

        fun addId(builder: FlatBufferBuilder, id: Offset<String>) = builder.add(0, id, 0)

        fun addSequenceId(builder: FlatBufferBuilder, sequenceId: UInt) = builder.add(1, sequenceId, 0u)

        fun addTokens(builder: FlatBufferBuilder, tokens: VectorOffset<UInt>) = builder.add(2, tokens, 0)

        fun createTokensVector(builder: FlatBufferBuilder, vector:UIntArray) : VectorOffset<UInt> {
            builder.startVector(4, vector.size, 4)
            for (i in vector.size - 1 downTo 0) {
                builder.add(vector[i])
            }
            return builder.endVector()
        }

        fun startTokensVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun addTextDelta(builder: FlatBufferBuilder, textDelta: Offset<String>) = builder.add(3, textDelta, 0)

        fun addIsFinal(builder: FlatBufferBuilder, isFinal: Boolean) = builder.add(4, isFinal, false)

        fun addShouldContinue(builder: FlatBufferBuilder, shouldContinue: Boolean) = builder.add(5, shouldContinue, true)

        fun addBatchTimeMs(builder: FlatBufferBuilder, batchTimeMs: UInt) = builder.add(6, batchTimeMs, 0u)

        fun addCumulativeTokens(builder: FlatBufferBuilder, cumulativeTokens: UInt) = builder.add(7, cumulativeTokens, 0u)

        fun addInstantaneousSpeed(builder: FlatBufferBuilder, instantaneousSpeed: Double) = builder.add(8, instantaneousSpeed, 0.0)

        fun endTokenStream(builder: FlatBufferBuilder) : Offset<TokenStream> {
            val o: Offset<TokenStream> = builder.endTable()
            return o
        }
    }
}

typealias TokenStreamOffsetArray = OffsetArray<TokenStream>

inline fun TokenStreamOffsetArray(size: Int, crossinline call: (Int) -> Offset<TokenStream>): TokenStreamOffsetArray =
    TokenStreamOffsetArray(IntArray(size) { call(it).value })
