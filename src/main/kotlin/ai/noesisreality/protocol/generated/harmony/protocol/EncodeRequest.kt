// automatically generated by the FlatBuffers compiler, do not modify

package harmony.protocol

import com.google.flatbuffers.kotlin.*
import kotlin.jvm.JvmInline
@Suppress("unused")
class EncodeRequest : Table() {

    fun init(i: Int, buffer: ReadWriteBuffer) : EncodeRequest = reset(i, buffer)

    val text : String? get() = lookupField(4, null ) { string(it + bufferPos) }
    fun textAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 4, 1)

    val formatType : Byte get() = lookupField(6, 0 ) { bb.get(it + bufferPos) }

    companion object {
        fun validateVersion() = VERSION_2_0_8

        fun asRoot(buffer: ReadWriteBuffer) : EncodeRequest = asRoot(buffer, EncodeRequest())
        fun asRoot(buffer: ReadWriteBuffer, obj: EncodeRequest) : EncodeRequest = obj.init(buffer.getInt(buffer.limit) + buffer.limit, buffer)


        fun createEncodeRequest(builder: FlatBufferBuilder, textOffset: Offset<String>, formatType: Byte) : Offset<EncodeRequest> {
            builder.startTable(2)
            addText(builder, textOffset)
            addFormatType(builder, formatType)
            return endEncodeRequest(builder)
        }
        fun startEncodeRequest(builder: FlatBufferBuilder) = builder.startTable(2)

        fun addText(builder: FlatBufferBuilder, text: Offset<String>) = builder.add(0, text, 0)

        fun addFormatType(builder: FlatBufferBuilder, formatType: Byte) = builder.add(1, formatType, 0)

        fun endEncodeRequest(builder: FlatBufferBuilder) : Offset<EncodeRequest> {
            val o: Offset<EncodeRequest> = builder.endTable()
            return o
        }
    }
}

typealias EncodeRequestOffsetArray = OffsetArray<EncodeRequest>

inline fun EncodeRequestOffsetArray(size: Int, crossinline call: (Int) -> Offset<EncodeRequest>): EncodeRequestOffsetArray =
    EncodeRequestOffsetArray(IntArray(size) { call(it).value })
