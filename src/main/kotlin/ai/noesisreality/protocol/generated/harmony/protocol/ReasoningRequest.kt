// automatically generated by the FlatBuffers compiler, do not modify

package harmony.protocol

import com.google.flatbuffers.kotlin.*
import kotlin.jvm.JvmInline
@Suppress("unused")
class ReasoningRequest : Table() {

    fun init(i: Int, buffer: ReadWriteBuffer) : ReasoningRequest = reset(i, buffer)

    val task : String? get() = lookupField(4, null ) { string(it + bufferPos) }
    fun taskAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 4, 1)

    val context : String? get() = lookupField(6, null ) { string(it + bufferPos) }
    fun contextAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 6, 1)

    val reasoningLevel : Byte get() = lookupField(8, 1 ) { bb.get(it + bufferPos) }

    val maxSteps : UInt get() = lookupField(10, 10u ) { bb.getUInt(it + bufferPos) }

    val stepTimeoutMs : UInt get() = lookupField(12, 5000u ) { bb.getUInt(it + bufferPos) }

    val includeThinking : Boolean get() = lookupField(14, true ) { 0.toByte() != bb.get(it + bufferPos) }

    companion object {
        fun validateVersion() = VERSION_2_0_8

        fun asRoot(buffer: ReadWriteBuffer) : ReasoningRequest = asRoot(buffer, ReasoningRequest())
        fun asRoot(buffer: ReadWriteBuffer, obj: ReasoningRequest) : ReasoningRequest = obj.init(buffer.getInt(buffer.limit) + buffer.limit, buffer)


        fun createReasoningRequest(builder: FlatBufferBuilder, taskOffset: Offset<String>, contextOffset: Offset<String>, reasoningLevel: Byte, maxSteps: UInt, stepTimeoutMs: UInt, includeThinking: Boolean) : Offset<ReasoningRequest> {
            builder.startTable(6)
            addStepTimeoutMs(builder, stepTimeoutMs)
            addMaxSteps(builder, maxSteps)
            addContext(builder, contextOffset)
            addTask(builder, taskOffset)
            addIncludeThinking(builder, includeThinking)
            addReasoningLevel(builder, reasoningLevel)
            return endReasoningRequest(builder)
        }
        fun startReasoningRequest(builder: FlatBufferBuilder) = builder.startTable(6)

        fun addTask(builder: FlatBufferBuilder, task: Offset<String>) = builder.add(0, task, 0)

        fun addContext(builder: FlatBufferBuilder, context: Offset<String>) = builder.add(1, context, 0)

        fun addReasoningLevel(builder: FlatBufferBuilder, reasoningLevel: Byte) = builder.add(2, reasoningLevel, 1)

        fun addMaxSteps(builder: FlatBufferBuilder, maxSteps: UInt) = builder.add(3, maxSteps, 10u)

        fun addStepTimeoutMs(builder: FlatBufferBuilder, stepTimeoutMs: UInt) = builder.add(4, stepTimeoutMs, 5000u)

        fun addIncludeThinking(builder: FlatBufferBuilder, includeThinking: Boolean) = builder.add(5, includeThinking, true)

        fun endReasoningRequest(builder: FlatBufferBuilder) : Offset<ReasoningRequest> {
            val o: Offset<ReasoningRequest> = builder.endTable()
            return o
        }
    }
}

typealias ReasoningRequestOffsetArray = OffsetArray<ReasoningRequest>

inline fun ReasoningRequestOffsetArray(size: Int, crossinline call: (Int) -> Offset<ReasoningRequest>): ReasoningRequestOffsetArray =
    ReasoningRequestOffsetArray(IntArray(size) { call(it).value })
