// automatically generated by the FlatBuffers compiler, do not modify

package harmony.protocol

import com.google.flatbuffers.kotlin.*
import kotlin.jvm.JvmInline
@Suppress("unused")
class HarmonyResponse : Table() {

    fun init(i: Int, buffer: ReadWriteBuffer) : HarmonyResponse = reset(i, buffer)

    val id : String? get() = lookupField(4, null ) { string(it + bufferPos) }
    fun idAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 4, 1)

    fun tokens(j: Int) : UInt = lookupField(6, 0u ) { bb.getUInt(vector(it) + j * 4) }
    val tokensLength : Int get() = lookupField(6, 0 ) { vectorLength(it) }
    fun tokensAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 6, 4)

    val text : String? get() = lookupField(8, null ) { string(it + bufferPos) }
    fun textAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 8, 1)

    fun tokenMetadata(j: Int) : harmony.protocol.TokenMetadata? = tokenMetadata(harmony.protocol.TokenMetadata(), j)
    fun tokenMetadata(obj: harmony.protocol.TokenMetadata, j: Int) : harmony.protocol.TokenMetadata? = lookupField(10, null ) { obj.init(indirect(vector(it) + j * 4), bb) }
    val tokenMetadataLength : Int get() = lookupField(10, 0 ) { vectorLength(it) }

    val reasoningContext : harmony.protocol.ReasoningContext? get() = reasoningContext(harmony.protocol.ReasoningContext())
    fun reasoningContext(obj: harmony.protocol.ReasoningContext) : harmony.protocol.ReasoningContext? = lookupField(12, null ) { obj.init(indirect(it + bufferPos), bb) }

    val encodingTimeMs : UInt get() = lookupField(14, 0u ) { bb.getUInt(it + bufferPos) }

    val tokenCount : UInt get() = lookupField(16, 0u ) { bb.getUInt(it + bufferPos) }

    val error : String? get() = lookupField(18, null ) { string(it + bufferPos) }
    fun errorAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 18, 1)

    companion object {
        fun validateVersion() = VERSION_2_0_8

        fun asRoot(buffer: ReadWriteBuffer) : HarmonyResponse = asRoot(buffer, HarmonyResponse())
        fun asRoot(buffer: ReadWriteBuffer, obj: HarmonyResponse) : HarmonyResponse = obj.init(buffer.getInt(buffer.limit) + buffer.limit, buffer)


        fun createHarmonyResponse(builder: FlatBufferBuilder, idOffset: Offset<String>, tokensOffset: VectorOffset<UInt>, textOffset: Offset<String>, tokenMetadataOffset: VectorOffset<harmony.protocol.TokenMetadata>, reasoningContextOffset: Offset<harmony.protocol.ReasoningContext>, encodingTimeMs: UInt, tokenCount: UInt, errorOffset: Offset<String>) : Offset<HarmonyResponse> {
            builder.startTable(8)
            addError(builder, errorOffset)
            addTokenCount(builder, tokenCount)
            addEncodingTimeMs(builder, encodingTimeMs)
            addReasoningContext(builder, reasoningContextOffset)
            addTokenMetadata(builder, tokenMetadataOffset)
            addText(builder, textOffset)
            addTokens(builder, tokensOffset)
            addId(builder, idOffset)
            return endHarmonyResponse(builder)
        }
        fun startHarmonyResponse(builder: FlatBufferBuilder) = builder.startTable(8)

        fun addId(builder: FlatBufferBuilder, id: Offset<String>) = builder.add(0, id, 0)

        fun addTokens(builder: FlatBufferBuilder, tokens: VectorOffset<UInt>) = builder.add(1, tokens, 0)

        fun createTokensVector(builder: FlatBufferBuilder, vector:UIntArray) : VectorOffset<UInt> {
            builder.startVector(4, vector.size, 4)
            for (i in vector.size - 1 downTo 0) {
                builder.add(vector[i])
            }
            return builder.endVector()
        }

        fun startTokensVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun addText(builder: FlatBufferBuilder, text: Offset<String>) = builder.add(2, text, 0)

        fun addTokenMetadata(builder: FlatBufferBuilder, tokenMetadata: VectorOffset<harmony.protocol.TokenMetadata>) = builder.add(3, tokenMetadata, 0)

        fun createTokenMetadataVector(builder: FlatBufferBuilder, vector:harmony.protocol.TokenMetadataOffsetArray) : VectorOffset<harmony.protocol.TokenMetadata> {
            builder.startVector(4, vector.size, 4)
            for (i in vector.size - 1 downTo 0) {
                builder.add(vector[i])
            }
            return builder.endVector()
        }

        fun startTokenMetadataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun addReasoningContext(builder: FlatBufferBuilder, reasoningContext: Offset<harmony.protocol.ReasoningContext>) = builder.add(4, reasoningContext, 0)

        fun addEncodingTimeMs(builder: FlatBufferBuilder, encodingTimeMs: UInt) = builder.add(5, encodingTimeMs, 0u)

        fun addTokenCount(builder: FlatBufferBuilder, tokenCount: UInt) = builder.add(6, tokenCount, 0u)

        fun addError(builder: FlatBufferBuilder, error: Offset<String>) = builder.add(7, error, 0)

        fun endHarmonyResponse(builder: FlatBufferBuilder) : Offset<HarmonyResponse> {
            val o: Offset<HarmonyResponse> = builder.endTable()
            return o
        }

        fun finishHarmonyResponseBuffer(builder: FlatBufferBuilder, offset: Offset<HarmonyResponse>) = builder.finish(offset)

        fun finishSizePrefixedHarmonyResponseBuffer(builder: FlatBufferBuilder, offset: Offset<HarmonyResponse>) = builder.finishSizePrefixed(offset)
    }
}

typealias HarmonyResponseOffsetArray = OffsetArray<HarmonyResponse>

inline fun HarmonyResponseOffsetArray(size: Int, crossinline call: (Int) -> Offset<HarmonyResponse>): HarmonyResponseOffsetArray =
    HarmonyResponseOffsetArray(IntArray(size) { call(it).value })
