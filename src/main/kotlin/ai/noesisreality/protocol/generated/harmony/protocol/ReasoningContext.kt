// automatically generated by the FlatBuffers compiler, do not modify

package harmony.protocol

import com.google.flatbuffers.kotlin.*
import kotlin.jvm.JvmInline
@Suppress("unused")
class ReasoningContext : Table() {

    fun init(i: Int, buffer: ReadWriteBuffer) : ReasoningContext = reset(i, buffer)

    val taskSummary : String? get() = lookupField(4, null ) { string(it + bufferPos) }
    fun taskSummaryAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 4, 1)

    fun reasoningSteps(j: Int) : harmony.protocol.HarmonyReasoningStep? = reasoningSteps(harmony.protocol.HarmonyReasoningStep(), j)
    fun reasoningSteps(obj: harmony.protocol.HarmonyReasoningStep, j: Int) : harmony.protocol.HarmonyReasoningStep? = lookupField(6, null ) { obj.init(indirect(vector(it) + j * 4), bb) }
    val reasoningStepsLength : Int get() = lookupField(6, 0 ) { vectorLength(it) }

    fun contextTokens(j: Int) : UInt = lookupField(8, 0u ) { bb.getUInt(vector(it) + j * 4) }
    val contextTokensLength : Int get() = lookupField(8, 0 ) { vectorLength(it) }
    fun contextTokensAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 8, 4)

    val totalThinkingTimeMs : UInt get() = lookupField(10, 0u ) { bb.getUInt(it + bufferPos) }

    val confidenceScore : Float get() = lookupField(12, 0.0f ) { bb.getFloat(it + bufferPos) }

    val reasoningDepth : Byte get() = lookupField(14, 0 ) { bb.get(it + bufferPos) }

    companion object {
        fun validateVersion() = VERSION_2_0_8

        fun asRoot(buffer: ReadWriteBuffer) : ReasoningContext = asRoot(buffer, ReasoningContext())
        fun asRoot(buffer: ReadWriteBuffer, obj: ReasoningContext) : ReasoningContext = obj.init(buffer.getInt(buffer.limit) + buffer.limit, buffer)


        fun createReasoningContext(builder: FlatBufferBuilder, taskSummaryOffset: Offset<String>, reasoningStepsOffset: VectorOffset<harmony.protocol.HarmonyReasoningStep>, contextTokensOffset: VectorOffset<UInt>, totalThinkingTimeMs: UInt, confidenceScore: Float, reasoningDepth: Byte) : Offset<ReasoningContext> {
            builder.startTable(6)
            addConfidenceScore(builder, confidenceScore)
            addTotalThinkingTimeMs(builder, totalThinkingTimeMs)
            addContextTokens(builder, contextTokensOffset)
            addReasoningSteps(builder, reasoningStepsOffset)
            addTaskSummary(builder, taskSummaryOffset)
            addReasoningDepth(builder, reasoningDepth)
            return endReasoningContext(builder)
        }
        fun startReasoningContext(builder: FlatBufferBuilder) = builder.startTable(6)

        fun addTaskSummary(builder: FlatBufferBuilder, taskSummary: Offset<String>) = builder.add(0, taskSummary, 0)

        fun addReasoningSteps(builder: FlatBufferBuilder, reasoningSteps: VectorOffset<harmony.protocol.HarmonyReasoningStep>) = builder.add(1, reasoningSteps, 0)

        fun createReasoningStepsVector(builder: FlatBufferBuilder, vector:harmony.protocol.HarmonyReasoningStepOffsetArray) : VectorOffset<harmony.protocol.HarmonyReasoningStep> {
            builder.startVector(4, vector.size, 4)
            for (i in vector.size - 1 downTo 0) {
                builder.add(vector[i])
            }
            return builder.endVector()
        }

        fun startReasoningStepsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun addContextTokens(builder: FlatBufferBuilder, contextTokens: VectorOffset<UInt>) = builder.add(2, contextTokens, 0)

        fun createContextTokensVector(builder: FlatBufferBuilder, vector:UIntArray) : VectorOffset<UInt> {
            builder.startVector(4, vector.size, 4)
            for (i in vector.size - 1 downTo 0) {
                builder.add(vector[i])
            }
            return builder.endVector()
        }

        fun startContextTokensVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun addTotalThinkingTimeMs(builder: FlatBufferBuilder, totalThinkingTimeMs: UInt) = builder.add(3, totalThinkingTimeMs, 0u)

        fun addConfidenceScore(builder: FlatBufferBuilder, confidenceScore: Float) = builder.add(4, confidenceScore, 0.0f)

        fun addReasoningDepth(builder: FlatBufferBuilder, reasoningDepth: Byte) = builder.add(5, reasoningDepth, 0)

        fun endReasoningContext(builder: FlatBufferBuilder) : Offset<ReasoningContext> {
            val o: Offset<ReasoningContext> = builder.endTable()
            return o
        }
    }
}

typealias ReasoningContextOffsetArray = OffsetArray<ReasoningContext>

inline fun ReasoningContextOffsetArray(size: Int, crossinline call: (Int) -> Offset<ReasoningContext>): ReasoningContextOffsetArray =
    ReasoningContextOffsetArray(IntArray(size) { call(it).value })
