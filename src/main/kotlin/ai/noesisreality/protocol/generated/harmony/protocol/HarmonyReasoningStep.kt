// automatically generated by the FlatBuffers compiler, do not modify

package harmony.protocol

import com.google.flatbuffers.kotlin.*
import kotlin.jvm.JvmInline
@Suppress("unused")
class HarmonyReasoningStep : Table() {

    fun init(i: Int, buffer: ReadWriteBuffer) : HarmonyReasoningStep = reset(i, buffer)

    val stepId : UInt get() = lookupField(4, 0u ) { bb.getUInt(it + bufferPos) }

    val stepType : String? get() = lookupField(6, null ) { string(it + bufferPos) }
    fun stepTypeAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 6, 1)

    val content : String? get() = lookupField(8, null ) { string(it + bufferPos) }
    fun contentAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 8, 1)

    val tokenRangeStart : UInt get() = lookupField(10, 0u ) { bb.getUInt(it + bufferPos) }

    val tokenRangeEnd : UInt get() = lookupField(12, 0u ) { bb.getUInt(it + bufferPos) }

    val processingTimeMs : UInt get() = lookupField(14, 0u ) { bb.getUInt(it + bufferPos) }

    val confidence : Float get() = lookupField(16, 0.0f ) { bb.getFloat(it + bufferPos) }

    fun premises(j: Int) : String? = lookupField(18, null ) { string(vector(it) + j * 4) }
    val premisesLength : Int get() = lookupField(18, 0 ) { vectorLength(it) }

    fun conclusions(j: Int) : String? = lookupField(20, null ) { string(vector(it) + j * 4) }
    val conclusionsLength : Int get() = lookupField(20, 0 ) { vectorLength(it) }

    fun evidence(j: Int) : String? = lookupField(22, null ) { string(vector(it) + j * 4) }
    val evidenceLength : Int get() = lookupField(22, 0 ) { vectorLength(it) }

    companion object {
        fun validateVersion() = VERSION_2_0_8

        fun asRoot(buffer: ReadWriteBuffer) : HarmonyReasoningStep = asRoot(buffer, HarmonyReasoningStep())
        fun asRoot(buffer: ReadWriteBuffer, obj: HarmonyReasoningStep) : HarmonyReasoningStep = obj.init(buffer.getInt(buffer.limit) + buffer.limit, buffer)


        fun createHarmonyReasoningStep(builder: FlatBufferBuilder, stepId: UInt, stepTypeOffset: Offset<String>, contentOffset: Offset<String>, tokenRangeStart: UInt, tokenRangeEnd: UInt, processingTimeMs: UInt, confidence: Float, premisesOffset: VectorOffset<String>, conclusionsOffset: VectorOffset<String>, evidenceOffset: VectorOffset<String>) : Offset<HarmonyReasoningStep> {
            builder.startTable(10)
            addEvidence(builder, evidenceOffset)
            addConclusions(builder, conclusionsOffset)
            addPremises(builder, premisesOffset)
            addConfidence(builder, confidence)
            addProcessingTimeMs(builder, processingTimeMs)
            addTokenRangeEnd(builder, tokenRangeEnd)
            addTokenRangeStart(builder, tokenRangeStart)
            addContent(builder, contentOffset)
            addStepType(builder, stepTypeOffset)
            addStepId(builder, stepId)
            return endHarmonyReasoningStep(builder)
        }
        fun startHarmonyReasoningStep(builder: FlatBufferBuilder) = builder.startTable(10)

        fun addStepId(builder: FlatBufferBuilder, stepId: UInt) = builder.add(0, stepId, 0u)

        fun addStepType(builder: FlatBufferBuilder, stepType: Offset<String>) = builder.add(1, stepType, 0)

        fun addContent(builder: FlatBufferBuilder, content: Offset<String>) = builder.add(2, content, 0)

        fun addTokenRangeStart(builder: FlatBufferBuilder, tokenRangeStart: UInt) = builder.add(3, tokenRangeStart, 0u)

        fun addTokenRangeEnd(builder: FlatBufferBuilder, tokenRangeEnd: UInt) = builder.add(4, tokenRangeEnd, 0u)

        fun addProcessingTimeMs(builder: FlatBufferBuilder, processingTimeMs: UInt) = builder.add(5, processingTimeMs, 0u)

        fun addConfidence(builder: FlatBufferBuilder, confidence: Float) = builder.add(6, confidence, 0.0f)

        fun addPremises(builder: FlatBufferBuilder, premises: VectorOffset<String>) = builder.add(7, premises, 0)

        fun createPremisesVector(builder: FlatBufferBuilder, vector:StringOffsetArray) : VectorOffset<String> {
            builder.startVector(4, vector.size, 4)
            for (i in vector.size - 1 downTo 0) {
                builder.add(vector[i])
            }
            return builder.endVector()
        }

        fun startPremisesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun addConclusions(builder: FlatBufferBuilder, conclusions: VectorOffset<String>) = builder.add(8, conclusions, 0)

        fun createConclusionsVector(builder: FlatBufferBuilder, vector:StringOffsetArray) : VectorOffset<String> {
            builder.startVector(4, vector.size, 4)
            for (i in vector.size - 1 downTo 0) {
                builder.add(vector[i])
            }
            return builder.endVector()
        }

        fun startConclusionsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun addEvidence(builder: FlatBufferBuilder, evidence: VectorOffset<String>) = builder.add(9, evidence, 0)

        fun createEvidenceVector(builder: FlatBufferBuilder, vector:StringOffsetArray) : VectorOffset<String> {
            builder.startVector(4, vector.size, 4)
            for (i in vector.size - 1 downTo 0) {
                builder.add(vector[i])
            }
            return builder.endVector()
        }

        fun startEvidenceVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun endHarmonyReasoningStep(builder: FlatBufferBuilder) : Offset<HarmonyReasoningStep> {
            val o: Offset<HarmonyReasoningStep> = builder.endTable()
            return o
        }
    }
}

typealias HarmonyReasoningStepOffsetArray = OffsetArray<HarmonyReasoningStep>

inline fun HarmonyReasoningStepOffsetArray(size: Int, crossinline call: (Int) -> Offset<HarmonyReasoningStep>): HarmonyReasoningStepOffsetArray =
    HarmonyReasoningStepOffsetArray(IntArray(size) { call(it).value })
