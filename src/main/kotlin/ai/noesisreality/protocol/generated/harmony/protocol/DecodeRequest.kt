// automatically generated by the FlatBuffers compiler, do not modify

package harmony.protocol

import com.google.flatbuffers.kotlin.*
import kotlin.jvm.JvmInline
@Suppress("unused")
class DecodeRequest : Table() {

    fun init(i: Int, buffer: ReadWriteBuffer) : DecodeRequest = reset(i, buffer)

    fun tokens(j: Int) : UInt = lookupField(4, 0u ) { bb.getUInt(vector(it) + j * 4) }
    val tokensLength : Int get() = lookupField(4, 0 ) { vectorLength(it) }
    fun tokensAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 4, 4)

    val includeMetadata : Boolean get() = lookupField(6, false ) { 0.toByte() != bb.get(it + bufferPos) }

    companion object {
        fun validateVersion() = VERSION_2_0_8

        fun asRoot(buffer: ReadWriteBuffer) : DecodeRequest = asRoot(buffer, DecodeRequest())
        fun asRoot(buffer: ReadWriteBuffer, obj: DecodeRequest) : DecodeRequest = obj.init(buffer.getInt(buffer.limit) + buffer.limit, buffer)


        fun createDecodeRequest(builder: FlatBufferBuilder, tokensOffset: VectorOffset<UInt>, includeMetadata: Boolean) : Offset<DecodeRequest> {
            builder.startTable(2)
            addTokens(builder, tokensOffset)
            addIncludeMetadata(builder, includeMetadata)
            return endDecodeRequest(builder)
        }
        fun startDecodeRequest(builder: FlatBufferBuilder) = builder.startTable(2)

        fun addTokens(builder: FlatBufferBuilder, tokens: VectorOffset<UInt>) = builder.add(0, tokens, 0)

        fun createTokensVector(builder: FlatBufferBuilder, vector:UIntArray) : VectorOffset<UInt> {
            builder.startVector(4, vector.size, 4)
            for (i in vector.size - 1 downTo 0) {
                builder.add(vector[i])
            }
            return builder.endVector()
        }

        fun startTokensVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun addIncludeMetadata(builder: FlatBufferBuilder, includeMetadata: Boolean) = builder.add(1, includeMetadata, false)

        fun endDecodeRequest(builder: FlatBufferBuilder) : Offset<DecodeRequest> {
            val o: Offset<DecodeRequest> = builder.endTable()
            return o
        }
    }
}

typealias DecodeRequestOffsetArray = OffsetArray<DecodeRequest>

inline fun DecodeRequestOffsetArray(size: Int, crossinline call: (Int) -> Offset<DecodeRequest>): DecodeRequestOffsetArray =
    DecodeRequestOffsetArray(IntArray(size) { call(it).value })
